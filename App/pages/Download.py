from io import BytesIO
from pathlib import Path

import streamlit as st
from pytube import YouTube

from pytube import YouTube, Search

import pandas as pd
import re

import zipfile
from multiprocessing import Process, Queue


def create_filename(artists, title):
    filename = ""
    all_artist = artists.split(",")
    
    if len(all_artist) > 2:
        all_artist = ",".join(all_artist[:2])+"..."
    else:
        all_artist = ",".join(all_artist[:2])
    
    filename +=all_artist


    to_remove = "[<>:\/\\|\?\*]"
    expr = re.compile(to_remove)
    clean_title = re.sub(expr,"_",title)

    filename+= "_"+clean_title
    return filename


def get_stream(queue,infos):
    curr_artist = infos[0]
    curr_title = infos[1]
    to_find = curr_artist + " " + curr_title
    s = Search(to_find+ " Auto-generated by YouTube")
    best_search = s.results[0]
    str_f = best_search.streams.filter(only_audio=True).order_by("abr").desc().first()
    #filename = best_search.title + " " + best_search.author

    buffer = BytesIO()

    filename = create_filename(curr_artist,curr_title)
    
    str_f.stream_to_buffer(buffer)
    #st.audio(buffer, format='audio/mpeg')
    buffer.seek(0)

    queue.put((buffer.getvalue(),best_search,filename,infos[2]))

#@st.cache_data(show_spinner=False)
def download_audio_to_buffer(data_todo,nb_song,ctx):
    list_buffers = []
    l_infos = []
    
    process = 4
    end = False
    for ind in data_todo.index:

        if (process + ind) > nb_song and not end:
            process = nb_song - ind
            end = True

        curr_artist = data_todo["artist"][ind]
        curr_title = data_todo["title"][ind]
        #print(f"proccessing {curr_artist} -- {curr_title}")
        
        #to_find = curr_artist + " " + curr_title 
        
        l_infos.append((curr_artist,curr_title,ind))

        if len(l_infos) % process == 0:
            #multiprocessing
            q = Queue()
            processes = []
            #rets = []
            for info in l_infos:
                p = Process(target=get_stream, args=(q,info))
                processes.append(p)
                p.start()
            
            for p in processes:
                ret = q.get() # will block
                #rets.append(ret)
                buff_ret, best_search, filename, indice = ret
                st.session_state["data"].loc[indice,"downloaded"] = True
                #df.loc[ind,"ytb_link"] = f"https://www.youtube.com/watch?v={best_search.video_id}"
                st.session_state["data"].loc[indice,"video_id"] = best_search.video_id
                ctx.write(filename)
                list_buffers.append((buff_ret,filename))

            for p in processes:
                p.join()                

            l_infos = []
 
    
    return list_buffers

def main():
    st.set_page_config(layout="centered")
    st.title("Download Your liked songs")

    data = st.session_state.get("data", None)
    audio_streams = st.session_state.get("audio_streams", "")
    if data is not None:
        ctx_main = st.container()
        ctx = st.container(height=400,border=True)
        ctx2 = st.container()
        ctx_main.write("This process can take long time, also it may not contains the good music. Because it searchs on Youtube so there may contains audio from clip video")
        nb_song = len(data)
        audio_streams = st.session_state.get("audios", [])

        if 'downloaded' not in data.columns:
            data["downloaded"] = [False for i in range(nb_song)]
        
        if 'video_id' not in data.columns:
            data["video_id"] = ["" for i in range(nb_song)] #if you want to generate playlist for youtube or know where it's come from

        btn_collect = ctx_main.button("Get Yours Liked Songs")

        if btn_collect:
            with st.spinner("Downloading Audio Stream from Youtube..."):
                data_todo = data.loc[data['downloaded'] == False]
                audio_streams = download_audio_to_buffer(data_todo,nb_song,ctx)
            
            st.session_state["audio_streams"] = audio_streams

            if len(audio_streams) > 0 :
                # Create a zip file and add all audio files to it
                zip_buffer = BytesIO()
                with zipfile.ZipFile(zip_buffer, "a", zipfile.ZIP_DEFLATED, False) as zipf:
                    for idx, (audio_stream, filename) in enumerate(audio_streams):
                        zipf.writestr(f'{filename}.mp3', audio_stream)

                output_zip_file = "liked_songs.zip"
                ctx2.download_button(
                        "Download Liked Song", 
                        file_name=output_zip_file, 
                        mime="application/zip", 
                        data=zip_buffer
                    )
                ctx2.success("Yata all videos downloaded in old fashion way! So be carefull about some audios...")
    else:
        st.write("No data available. Please connect to spotify/Upload csv file and go to page Data in order to get data")
if __name__ == "__main__":
    main()